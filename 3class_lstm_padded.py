# -*- coding: utf-8 -*-
"""3class_LSTM_padded.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jYP90Fk_59Jfj8Sq7Ya0eR8ycv_p1snu
"""

'''This code gives the neural network model for classification of multi-particle events using padded LSTM approach having both 3-class classification'''

import numpy as np
!pip install keras_sequential_ascii
import keras
import pandas as pd
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Reshape
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D, ZeroPadding2D
from keras.layers import Dense , Flatten ,Embedding,Masking,Input, CuDNNLSTM
from keras.layers import Activation
from sklearn.preprocessing import MinMaxScaler
from keras import backend as K
from keras.layers import LSTM
from keras_sequential_ascii import sequential_model_to_ascii_printout
from keras.utils import plot_model
from keras.utils import np_utils
from keras.optimizers import SGD
from keras.constraints import maxnorm
from keras.callbacks import EarlyStopping
from keras.preprocessing.text import one_hot,Tokenizer
from keras.preprocessing.sequence import pad_sequences
from nltk import word_tokenize,sent_tokenize
from keras.callbacks import ModelCheckpoint
from keras.models import load_model
from keras import metrics
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

import sys 
from keras.models import Model

from google.colab import drive
drive.mount('/content/drive')

with open("drive/My Drive/DblDifr/DblDifr00.txt") as dbl_difr:
    dbl_dif = [line.split() for line in dbl_difr]
with open("drive/My Drive/SinDifr/SinDifr00.txt") as sin_difr:
    sin_dif = [line.split() for line in sin_difr]
with open("drive/My Drive/MinBias/MinBias00.txt") as bckg:
    difr_bckg = [line.split() for line in bckg]
dbl_diff = np.array(dbl_dif)
sin_diff = np.array(sin_dif)
diff_bckg = np.array(difr_bckg)

for i in range(len(dbl_diff)):
  for j in range(len(dbl_diff[i])):
    dbl_diff[i][j] = float(dbl_diff[i][j])
for i in range(len(sin_diff)):
  for j in range(len(sin_diff[i])):
    sin_diff[i][j] = float(sin_diff[i][j])
for i in range(len(diff_bckg)):
  for j in range(len(diff_bckg[i])):
    diff_bckg[i][j] = float(diff_bckg[i][j])

dbl_diff_class = []
sin_diff_class = []
for i in range(dbl_diff.shape[0]):
  dbl_diff_class.append(1)      
  sin_diff_class.append(0)
diff_bckg_class = []
for i in range(diff_bckg.shape[0]):
  diff_bckg_class.append(2)

sin_dif_class = np.array(sin_diff_class)
dbl_dif_class = np.array(dbl_diff_class)
dif_bckg_class = np.array(diff_bckg_class)
diff_Stacked_data = np.concatenate((sin_diff,dbl_diff))
diff_Stacked_data = np.concatenate((diff_Stacked_data,diff_bckg))
                                                          # stacking the Signal and BAckground events  for classification
diff_Stacked_class = np.concatenate((sin_diff_class,dbl_diff_class))
diff_Stacked_class = np.concatenate((diff_Stacked_class,diff_bckg_class))

from sklearn.utils import shuffle     #shuffling the data
diff_Data_org, diff_Class_org = shuffle(diff_Stacked_data, diff_Stacked_class)

diff_pad_data = pad_sequences(diff_Data_org, padding='post')
print(diff_pad_data.shape)

diff_train, diff_test, diff_label_train, diff_label_test = train_test_split( diff_pad_data[0:80000], diff_Class_org[0:80000], test_size=0.3, random_state=42)  #Train-test spliting
diff_val = diff_test[12000:24000]
diff_label_val = diff_label_test[12000:24000]
diff_test = diff_test[0:12000]
diff_label_test = diff_label_test[0:12000]

diff_label_train = np_utils.to_categorical(diff_label_train, 3)
diff_label_test = np_utils.to_categorical(diff_label_test, 3)                   #Conversion of 1 and 0 to binary units for categorical cross entropy
diff_label_val = np_utils.to_categorical(diff_label_val, 3)
diff_train = np.reshape(diff_train,(diff_train.shape[0],diff_train.shape[1],1))
diff_test = np.reshape(diff_test,(diff_test.shape[0],diff_test.shape[1],1))
diff_val = np.reshape(diff_val,(diff_val.shape[0],diff_val.shape[1],1))

# Model variables
batch_size = 100
epochs = 5

# Used datasets
diff_data_train = diff_train
diff_data_test = diff_test 
diff_data_val = diff_val
diff_class_train = diff_label_train
diff_class_test = diff_label_test
diff_class_val = diff_label_val

def base_model():
  model = Sequential()
  model.add(Masking(mask_value=0, input_shape=(None,1)))
  model.add(LSTM(35,input_shape=(None,1),return_sequences=False))
  model.add(Dropout(rate = 0.3))
  
  model.add(Dense(3, activation='softmax'))
  model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=[metrics.categorical_accuracy]) 
  return model

diff_event_cf = base_model()
diff_event_cf.summary()
#sequential_model_to_ascii_printout(event_cf)
plot_model(diff_event_cf)

es = EarlyStopping(monitor='val_categorical_accuracy', mode='max', verbose=1, patience=10)
mc = ModelCheckpoint('best_model_three_lstm_mask.h5', monitor='val_categorical_accuracy', mode='max', verbose=1, save_best_only=True)
diff_event_cf = diff_event_cf.fit(diff_data_train, diff_class_train, batch_size=batch_size, epochs=epochs, validation_data=(diff_data_val,diff_class_val),shuffle=True, callbacks=[es, mc])
saved_model = load_model('best_model_three_lstm_mask.h5')

# evaluate loaded model
scores_train = saved_model.evaluate(diff_data_train, diff_class_train, verbose=0)
scores_test  = saved_model.evaluate(diff_data_test,  diff_class_test,  verbose=0)
scores_val   = saved_model.evaluate(diff_data_val,   diff_class_val,   verbose=0)
print("Accuracy Train: %.2f%% , Test: %.2f%% Val: %.2f%% " % (scores_train[1]*100, scores_test[1]*100, scores_val[1]*100))          #Efficiency(train and test)

# Confusion matrix result

from sklearn.metrics import classification_report, confusion_matrix
YY_pred = saved_model.predict(diff_data_test, verbose=2)
yy_pred = np.argmax(YY_pred, axis=1)

yy_test2 = np.argmax(diff_class_test, axis=1)



#confusion matrix
cm = confusion_matrix(np.argmax(diff_class_test,axis=1),yy_pred)                         #Confusion matrix
print(cm)

# Visualizing of confusion matrix
import seaborn as sn
import pandas  as pd


df_cm = pd.DataFrame(cm, range(3),
                  range(3))
plt.figure(figsize = (10,7))
sn.set(font_scale=1.4)#for label size
sn.heatmap(df_cm, annot=True,annot_kws={"size": 12})# font size
plt.show()

