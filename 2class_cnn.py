# -*- coding: utf-8 -*-
"""2class_CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XizUHL8NyyRgLoGxF7IBjxnvcVPHGJJg
"""

'''This code gives the neural network model for classification of multi-particle events using Conventional Neural Network by using 2-D Binary maps of the padded vectors approach having both 2-class classification'''

import numpy as np
!pip install keras_sequential_ascii
import keras
import pandas as pd
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Reshape
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D, ZeroPadding2D
from keras.layers import Dense , Flatten ,Embedding,Masking,Input, CuDNNLSTM
from keras.layers import Activation
from sklearn.preprocessing import MinMaxScaler
from keras import backend as K
from keras.layers import LSTM
from keras_sequential_ascii import sequential_model_to_ascii_printout
from keras.utils import plot_model
from keras.utils import np_utils
from keras.optimizers import SGD
from keras.constraints import maxnorm
from keras.callbacks import EarlyStopping
from keras.preprocessing.text import one_hot,Tokenizer
from keras.preprocessing.sequence import pad_sequences
from nltk import word_tokenize,sent_tokenize
from keras.callbacks import ModelCheckpoint
from keras.models import load_model
from keras import metrics
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

import sys 
from keras.models import Model

from google.colab import drive
drive.mount('/content/drive')

with open("drive/My Drive/Difr/Difr00.txt") as new_sig:
    new_signal = [line.split() for line in new_sig]
with open("drive/My Drive/MinBias/MinBias00.txt") as new_backg:
    new_background = [line.split() for line in new_backg]
new_sig_arr = np.array(new_signal)
new_back_arr = np.array(new_background)

for i in range(len(new_sig_arr)):
  for j in range(len(new_sig_arr[i])):
    new_sig_arr[i][j] = float(new_sig_arr[i][j])

for i in range(len(new_back_arr)):
  for j in range(len(new_back_arr[i])):
    new_back_arr[i][j] = float(new_back_arr[i][j])

new_signal_pythia_class = []
new_background_pythia_class = []
for i in range(new_sig_arr.shape[0]):
  new_signal_pythia_class.append(1)      #1--> Signal, 0--> Background
  new_background_pythia_class.append(0)
new_sig_pythia_class = np.array(new_signal_pythia_class)
new_back_pythia_class = np.array(new_background_pythia_class)
new_Stacked_data_pythia = np.concatenate((new_sig_arr,new_back_arr))
                                                          # stacking the Signal and BAckground events  for classification
new_Stacked_class_pythia = np.concatenate((new_sig_pythia_class,new_back_pythia_class))

from sklearn.utils import shuffle     #shuffling the data
new_Data_org_pythia, new_Class_org_pythia = shuffle(new_Stacked_data_pythia, new_Stacked_class_pythia)

new_pad_data_pythia = pad_sequences(new_Data_org_pythia, padding='post')
print(new_pad_data_pythia.shape)

'''Model Starts Here'''

hist_train, hist_test, label_train, label_test = train_test_split( new_pad_data_pythia, new_Class_org_pythia, test_size=0.3, random_state=42)  #Train-test spliting
hist_val = hist_test[30000:60000]
label_val = label_test[30000:60000]
hist_test = hist_test[0:30000]
label_test = label_test[0:30000]

import matplotlib.cm as cm
plt.title(label_test[30])
plt.imshow(np.reshape(hist_test[31],(9,15)), cmap=cm.binary)    #Dimensions of reshaped array for a dataset file is determined by total padded length of the feature vector. i.e if length is 135, the dimensions will be (9,15).
plt.show()

label_train = np_utils.to_categorical(label_train, 2)
label_test = np_utils.to_categorical(label_test, 2)
label_val = np_utils.to_categorical(label_val, 2)
img_rows = 9
img_cols = 15
img_size_flat = img_cols*img_rows
num_channels = 1
num_classes =2

hist_train = np.reshape(hist_train,(hist_train.shape[0],1,img_rows,img_cols))
hist_test = np.reshape(hist_test,(hist_test.shape[0],1,img_rows,img_cols))
hist_val = np.reshape(hist_test,(hist_val.shape[0],1,img_rows,img_cols))

# Define Model

def base_model():

    model = Sequential()
    input_shape=(1,img_rows,img_cols)

    model.add(Reshape((img_rows,img_cols,1),input_shape=input_shape))
    model.add(Conv2D(64,kernel_size = 2,activation='relu',input_shape=input_shape))
    model.add(Flatten())
    model.add(Dropout(rate = 0.2))
    model.add(Dense(320,activation='relu',kernel_constraint=maxnorm(3))) 
    model.add(Dropout(rate = 0.3))
    model.add(Dense(160,activation='relu',kernel_constraint=maxnorm(3))) 
    model.add(Dropout(rate = 0.3))

    model.add(Dense(num_classes, activation='softmax'))

    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=[metrics.categorical_accuracy]) 
    return model

# Vizualizing model structure
# Model summary (ascii)
cnn_n = base_model()
cnn_n.summary()

# Model printout (ascii)
sequential_model_to_ascii_printout(cnn_n)

# Plotting model in graphical mode
plot_model(cnn_n, to_file='CNN.png')  ###, show_shapes=True

# patient early stopping
es = EarlyStopping(monitor='val_categorical_accuracy', mode='max', verbose=1, patience=10)
mc = ModelCheckpoint('best_model_hist_conv2d.h5', monitor='val_categorical_accuracy', mode='max', verbose=1, save_best_only=True)
# fit model
cnn = cnn_n.fit(hist_train, label_train, batch_size=100, epochs=5, validation_data=(hist_test,label_test),shuffle=True, callbacks=[es, mc])
# load the saved model
saved_model = load_model('best_model_hist_conv2d.h5')

# evaluate loaded model
scores_train = saved_model.evaluate(hist_train, label_train, verbose=0)
scores_test  = saved_model.evaluate(hist_test,  label_test,  verbose=0)
scores_val   = saved_model.evaluate(hist_val,   label_val,   verbose=0)
print("Accuracy Train: %.2f%% , Test: %.2f%% Val: %.2f%% " % (scores_train[1]*100, scores_test[1]*100, scores_val[1]*100))          #Efficiency(train and test)

# Confusion matrix result

from sklearn.metrics import classification_report, confusion_matrix
YY_pred = saved_model.predict(hist_test, verbose=2)
yy_pred = np.argmax(YY_pred, axis=1)

yy_test2 = np.argmax(label_test, axis=1)



#confusion matrix
cm = confusion_matrix(np.argmax(label_test,axis=1),yy_pred)                         #Confusion matrix
print(cm)

# Visualizing of confusion matrix
import seaborn as sn
import pandas  as pd


df_cm = pd.DataFrame(cm, range(2),
                  range(2))
plt.figure(figsize = (10,7))
sn.set(font_scale=1.4)#for label size
sn.heatmap(df_cm, annot=True,annot_kws={"size": 12})# font size
plt.show()

